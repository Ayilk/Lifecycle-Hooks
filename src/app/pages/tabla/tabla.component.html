
  
  <table class="table table-dark table-hover">
    <thead>
      <tr>
        <th scope="col">Método Hooke</th>
        <th scope="col">Objetivo</th>
        <th scope="col">Momento</th>      
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row"><h4>ngOnChanges()</h4></th>
        <td >Responda cuando Angular establezca o restablezca las propiedades de entrada vinculadas a datos. <br>El método recibe un SimpleChangesobjeto de valores de propiedad actuales y anteriores.
          <br>NOTA :
          Esto sucede con mucha frecuencia, por lo que cualquier operación que realice aquí afecta significativamente el rendimiento.
          </td>
        <td>Llamado antes ngOnInit()(si el componente tiene entradas enlazadas) y cada vez que cambian una o más propiedades de entrada enlazadas a datos.
          <br>NOTA :
          Si su componente no tiene entradas o lo usa sin proporcionar ninguna entrada, el marco no llamará ngOnChanges().</td>
       
      </tr>
      <tr>
        <th scope="row"><h4>ngOnInit()</h4></th>
        <td>Inicialice la directiva o el componente después de que Angular primero muestre las propiedades vinculadas a los datos y establezca las propiedades de entrada de la directiva o el componente.<br> Consulte los detalles en Inicialización de un componente o directiva en este documento.</td>
        <td>Llamado una vez, después del primero ngOnChanges().<br> ngOnInit()todavía se llama incluso cuando ngOnChanges()no lo es (que es el caso cuando no hay entradas vinculadas a la plantilla).</td>
       
      </tr>
      <tr>
        <th scope="row"><h4>ngDoCheck()</h4></th>
        <td >Detecte y actúe sobre los cambios que Angular no puede o no detectará por sí solo. Consulte los detalles y el ejemplo en Definición de la detección de cambios personalizados en este documento.</td>
        <td>Llamado inmediatamente después ngOnChanges()de cada ejecución de detección de cambios e inmediatamente después ngOnInit()de la primera ejecución.</td>
      </tr>
      <tr>
        <th scope="row"><h4>ngAfterContentInit()</h4></th>
        <td >Responder después de que Angular proyecte contenido externo en la vista del componente o en la vista en la que se encuentra una directiva.
          </td>
        <td>Llamado una vez después de la primera ngDoCheck().</td>
      </tr>
      <tr>
        <th scope="row"><h4>ngAfterContentChecked()</h4></th>
        <td >Responda después de que Angular verifique el contenido proyectado en la directiva o el componente.
          </td>
        <td>Llamado después ngAfterContentInit()y cada posterior ngDoCheck().</td>
      </tr>
      <tr>
        <th scope="row"><h4>ngAfterViewInit()</h4></th>
        <td >Responda después de que Angular inicialice las vistas del componente y las vistas secundarias, o la vista que contiene la directiva.
          </td>
        <td>Llamado una vez después de la primera ngAfterContentChecked().</td>
      </tr>
      <tr>
        <th scope="row"><h4>ngAfterViewChecked()</h4></th>
        <td >Responda después de que Angular verifique las vistas del componente y las vistas secundarias, o la vista que contiene la directiva.</td>
        <td>Llamado después de ngAfterViewInit()y cada subsiguiente ngAfterContentChecked().</td>
      </tr>
      <tr>
        <th scope="row"><h4>ngOnDestroy()</h4></th>
        <td >Limpieza justo antes de que Angular destruya la directiva o el componente. Anule la suscripción de Observables y separe los controladores de eventos para evitar pérdidas de memoria.<br> Consulte los detalles en Limpieza de la destrucción de instancias en este documento.</td>
        <td>Llamado inmediatamente antes de que Angular destruya la directiva o el componente.</td>
      </tr>
    </tbody>
  </table>
